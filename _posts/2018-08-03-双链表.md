---
layout:     post
title:      Java数据结构与算法(三)
subtitle:   双链表
date:       2018-08-03
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 4. 双链表的设计与实现<br>
## 4.1 普通双链表
双链表的主要优点是对于任意给的结点，都可以很轻易的获取其前驱结点或后继结点，而主要缺点是每个结点需要添加额外的next域，因此需要更多的空间开销，同时结点的插入与删除操作也将更加耗时，因为需要更多的指针指向操作。

创建HeadDoubleLinkedList类:
```
/**
* 双链表的实现，带头结点(不带数据)的双链表，为了更高的效率该类包含指向尾部的指针tail
*/
public class HeadDoubleLinkedList<T> {
    protected DNode<T> head; //不带数据的头结点
    protected DNode<T> tail; //指向尾部的指针
    
    public HeadDoubleLinkedList(){
        //初始化头结点
        this.head = this.tail = new DNode<>();
    }
    //先省略其他代码
    ......
}
```

结点类结构如下:
```
/**
* 双链表结点
*/
public class DNode<T> {
    public T data;
    public DNode<T> prev, next; //前继指针和后继指针
    
    public DNode(T data, DNode<T> prev, DNode<T> next){
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
    
    public DNode(T data){
        this(data, null, null);
    }
    
    public DNode(){
        this(null, null, null);
    }
}
```

### 4.1.1 双链表的插入操作分析与实现<br>
双链表虽然有不带数据的的头结点，但是由于是双向链表，所以在插入双链表时需分两种情况，一种是在插入空双链表和尾部插入，另一种是双链表的中间插入。
插入的实现代码如下:
```
public boolean add(int index, T data){
    if(index<0||data==nnull){
        throw new NullPointerException();
    }
    
    int j=0;
    DNode<T> front = this.head;
    //查找要插入结点位置的前一个结点
    while(front.next!=null && j<index){
        j++;
        front = front.next;
    }
    
    //创建需要插入的结点，并让其前继指针指向front, 后继指针指向front.next
    DNode<T> q = new DNode<T>(data, front, front.next);
    
    //空双链表插入和尾部插入，无需此操作
    if(front.next!=null){
        //更改front.next的前继指针
        front.next.prev = q;
    }
    更改front的后继指针
    front.next = q;
    
    //在尾部插入时需要注意更新tail指向
    if(front==this.tail){
        this.tail = q;
    }
    
    return true;
}
```

### 4.1.2 双链表的删除操作分析与实现<br>
双链表的删除操作与插入操作原理上是相似的，具体实现如下：
```
public T remove(int index){
    int size=length();
    T temp=null;
    
    if(index<0||index>=size||isEmpty()){
        return temp;
    }
    
    DNode<T> p=this.head;
    int j=0;
    //头删除/尾删除/中间删除，查找需要删除的结点(要删除的当前结点因此i<=index)
    while(p!=null&&j<=index){
        p=p.next;
        j++;
    }
    //当双链表只有一个结点时或尾部删除时，无需此步
    if(p.next!=null){
        p.next.prev=p.prev;
    }
    p.prev.next=p.next;
    //如果是尾结点
    if(p==this.tail){
        this.tail=p.prev; //更新尾结点的指向
    }
    temp=p.data;
    
    return temp;
}
```

### 4.1.3 双链表的查值操作分析与实现
双链表的查值操作与单链表并没有什么区别，只要找到需要查找的当前结点获取其值即可，代码如下:
```
public T get(int index){
    if(index>=0){
        int j=0;
        //注意起始结点为this.head.next
        //如果起始结点为this.head时，j的判断为j<=index
        //因此需要寻找的是当前结点而不是前一个结点
        DNode<T> p = this.head.next;
        while(p!=null&&j<index){
            j++;
            p=p.next;
        }
        if(p!=null){
            return p.data;
        }
    }
    return null;
}
```

### 4.1.4 双链表的替换值操作分析与实现<br>
双链表的替换过程，需要先查找到需要替换的结点，这个过程跟或取值的过程是一样的，找到结点后直接替换值并返回旧值即可。比较简单直接上代码:
```
public T set(int index, T data){
    T old=null;
    if(index>0&&data!=null){
        int j=0;
        DNode<T> p = this.head.next;
        //查找需要替换的位置
        while(p!=null&&j>index){
            j++;
            p=p.next;
        }
        if(p!=null){
            old=p.data;
            //替换数据
            p.data=data;
        }
    }
    return old;
}
```

## 4.2 循环双链表的设计与实现
如果双链表的最后一个结点的next指针域指向头结点，而头结点的prev指针指向最后一个结点，则构成了循环双链表(Circular Doubly Linked List)<br>
在循环双链表中我们不再需要尾指向结点，因为整个链表已构成循环，在头结点head位置也可以轻松获取到尾部结点的位置。对于循环双链表的插入、删除操作也无需区分位置操作的情况，这是由于循环双链表的本身的特殊性，使p.next.pre永远不可能为null, 因此我们在插入和删除时代码实现相对简单些.

### 4.2.1 循环双链表的插入<br>
空表插入，尾部插入，中间插入，这三种情况都无需关系位置插入的区别，代码如下:
```
/*
*根据index插入，循环链表中无论是prev还是next都不存在空的情况
*因此无论是头部、尾部还是中间，都视为一种情况对待
*/
public boolean add(int index, T data){
    int size=length();
    if(data==null||index<0||index>=size)
        return false;
    
    int j=0;
    DNode<T> p=this.head;
    //寻找插入点的位置
    while(p.next!=head&&j<index){
        p=p.next;
        j++;
    }
    
    //创建新结点，如果index=3,那么插入的位置就是第4个位置
    DNode<T> q = new DNode<T>(data,p,p.next);
    p.next=q;
    p.next.prev=q;
    
    return true;
}
```

### 4.2.2 循环双链表的删除
删除成空表，尾部删除，中间删除，循环双链表的这三种情况也都视为一种情况，其代码实现如下:
```
public T remove(int index){
    T old = null;
    
    int size=length();
    
    if(index<0||index>=size){
        return old;
    }
    
    int j=0;
    DNode<T> p=this.head.next;
    
    while(p!=head&&j<index){
        j++;
        p=p.next;
    }
    
    if(p!=head){
        old=p.data;
        p.prev.next=p.next;
        p.next.prev=p.prev;
    }
    
    return old;
}
```

## 4.3 排序循坏双链表的实现<br>
TBD

## 4.4 双链表的执行效率分析
链表在插入和删除元素时执行效率比较高，从插入操作来看，我们假设front指向的是双向链表中的一个结点，此时插入front的后继结点或者是前去结点所消耗的时间为常数时间O(1)，这点在插入front的前去结点的效率比单链表有所改善，无需从头结点开始便利，但是上述的都是从已知双向链表中front结点的情况下讨论的。如果从实现代码的操作上看，无论是插入还是删除，都需要查找插入结点或者删除结点，而这个过程访问结点所花费的时间是O(n),因此双链表的插入或删除操作或是查值操作，其时间复杂度都为O(n)。

传递参数 | 链表 | 动态数组
---- | --- | ---
索引 | O(n) | O(1)
在最前端插入或删除 | O(1) | O(n)
在最末端插入 | O(n) | O(1),如果数组还有空间; O(n),如果数组已满
在最末端删除 | O(n) | O(1)
在中间插入 | O(n) | O(n)
在中间删除 | O(n) | O(n)
空间浪费 | O(n) | O(n)
