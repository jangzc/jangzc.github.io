---
layout:     post
title:      Java数据结构与算法(三)
subtitle:   双链表
date:       2018-08-03
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 4. 双链表的设计与实现<br>
## 4.1 概述
双链表的主要优点是对于任意给的结点，都可以很轻易的获取其前驱结点或后继结点，而主要缺点是每个结点需要添加额外的next域，因此需要更多的空间开销，同时结点的插入与删除操作也将更加耗时，因为需要更多的指针指向操作。

创建HeadDoubleLinkedList类:
```
/**
* 双链表的实现，带头结点(不带数据)的双链表，为了更高的效率该类包含指向尾部的指针tail
*/
public class HeadDoubleLinkedList<T> {
    protected DNode<T> head; //不带数据的头结点
    protected DNode<T> tail; //指向尾部的指针
    
    public HeadDoubleLinkedList(){
        //初始化头结点
        this.head = this.tail = new DNode<>();
    }
    //先省略其他代码
    ......
}
```

结点类结构如下:
```
/**
* 双链表结点
*/
public class DNode<T> {
    public T data;
    public DNode<T> prev, next; //前继指针和后继指针
    
    public DNode(T data, DNode<T> prev, DNode<T> next){
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
    
    public DNode(T data){
        this(data, null, null);
    }
    
    public DNode(){
        this(null, null, null);
    }
}
```

## 4.2 双链表的插入操作分析与实现<br>
双链表虽然有不带数据的的头结点，但是由于是双向链表，所以在插入双链表时需分两种情况，一种是在插入空双链表和尾部插入，另一种是双链表的中间插入。
插入的实现代码如下:
```
public boolean add(int index, T data){
    if(index<0||data==nnull){
        throw new NullPointerException();
    }
    
    int j=0;
    DNode<T> front = this.head;
    //查找要插入结点位置的前一个结点
    while(front.next!=null && j<index){
        j++;
        front = front.next;
    }
    
    //创建需要插入的结点，并让其前继指针指向front, 后继指针指向front.next
    DNode<T> q = new DNode<T>(data, front, front.next);
    
    //空双链表插入和尾部插入，无需此操作
    if(front.next!=null){
        //更改front.next的前继指针
        front.next.prev = q;
    }
    更改front的后继指针
    front.next = q;
    
    //在尾部插入时需要注意更新tail指向
    if(front==this.tail){
        this.tail = q;
    }
    
    return true;
}
```

## 4.3 双链表的删除操作分析与实现<br>
