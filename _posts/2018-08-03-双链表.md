---
layout:     post
title:      Java数据结构与算法(三)
subtitle:   双链表
date:       2018-08-03
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 4. 双链表的设计与实现<br>
## 4.1 普通双链表
双链表的主要优点是对于任意给的结点，都可以很轻易的获取其前驱结点或后继结点，而主要缺点是每个结点需要添加额外的next域，因此需要更多的空间开销，同时结点的插入与删除操作也将更加耗时，因为需要更多的指针指向操作。

创建HeadDoubleLinkedList类:
```
/**
* 双链表的实现，带头结点(不带数据)的双链表，为了更高的效率该类包含指向尾部的指针tail
*/
public class HeadDoubleLinkedList<T> {
    protected DNode<T> head; //不带数据的头结点
    protected DNode<T> tail; //指向尾部的指针
    
    public HeadDoubleLinkedList(){
        //初始化头结点
        this.head = this.tail = new DNode<>();
    }
    //先省略其他代码
    ......
}
```

结点类结构如下:
```
/**
* 双链表结点
*/
public class DNode<T> {
    public T data;
    public DNode<T> prev, next; //前继指针和后继指针
    
    public DNode(T data, DNode<T> prev, DNode<T> next){
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
    
    public DNode(T data){
        this(data, null, null);
    }
    
    public DNode(){
        this(null, null, null);
    }
}
```

### 4.1.1 双链表的插入操作分析与实现<br>
双链表虽然有不带数据的的头结点，但是由于是双向链表，所以在插入双链表时需分两种情况，一种是在插入空双链表和尾部插入，另一种是双链表的中间插入。
插入的实现代码如下:
```
public boolean add(int index, T data){
    if(index<0||data==nnull){
        throw new NullPointerException();
    }
    
    int j=0;
    DNode<T> front = this.head;
    //查找要插入结点位置的前一个结点
    while(front.next!=null && j<index){
        j++;
        front = front.next;
    }
    
    //创建需要插入的结点，并让其前继指针指向front, 后继指针指向front.next
    DNode<T> q = new DNode<T>(data, front, front.next);
    
    //空双链表插入和尾部插入，无需此操作
    if(front.next!=null){
        //更改front.next的前继指针
        front.next.prev = q;
    }
    更改front的后继指针
    front.next = q;
    
    //在尾部插入时需要注意更新tail指向
    if(front==this.tail){
        this.tail = q;
    }
    
    return true;
}
```

### 4.1.2 双链表的删除操作分析与实现<br>
双链表的删除操作与插入操作原理上是相似的，具体实现如下：
```
public T remove(int index){
    int size=length();
    T temp=null;
    
    if(index<0||index>=size||isEmpty()){
        return temp;
    }
    
    DNode<T> p=this.head;
    int j=0;
    //头删除/尾删除/中间删除，查找需要删除的结点(要删除的当前结点因此i<=index)
    while(p!=null&&j<=index){
        p=p.next;
        j++;
    }
    //当双链表只有一个结点时或尾部删除时，无需此步
    if(p.next!=null){
        p.next.prev=p.prev;
    }
    p.prev.next=p.next;
    //如果是尾结点
    if(p==this.tail){
        this.tail=p.prev; //更新尾结点的指向
    }
    temp=p.data;
    
    return temp;
}
```

### 4.1.3 双链表的查值操作分析与实现
双链表的查值操作与单链表并没有什么区别，只要找到需要查找的当前结点获取其值即可，代码如下:
```
public T get(int index){
    if(index>=0){
        int j=0;
        //注意起始结点为this.head.next
        //如果起始结点为this.head时，j的判断为j<=index
        //因此需要寻找的是当前结点而不是前一个结点
        DNode<T> p = this.head.next;
        while(p!=null&&j<index){
            j++;
            p=p.next;
        }
        if(p!=null){
            return p.data;
        }
    }
    return null;
}
```

### 4.1.4 双链表的替换值操作分析与实现<br>
双链表的替换过程，需要先查找到需要替换的结点，这个过程跟或取值的过程是一样的，找到结点后直接替换值并返回旧值即可。比较简单直接上代码:
```
public T set(int index, T data){
    T old=null;
    if(index>0&&data!=null){
        int j=0;
        DNode<T> p = this.head.next;
        //查找需要替换的位置
        while(p!=null&&j>index){
            j++;
            p=p.next;
        }
        if(p!=null){
            old=p.data;
            //替换数据
            p.data=data;
        }
    }
    return old;
}
```

## 4.2 循环双链表的设计与实现
