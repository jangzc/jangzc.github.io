---
layout:     post
title:      树基本概念与二叉树
subtitle:   Java数据结构与算法(七)
date:       2018-08-10
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 1. 树的基本概念与术语<br>
树是数据元素之间具有层次关系的非线性的结构，树是由n个节点组成的有限集合，n>0的树T由以下两个条件约定构成：
* (1) 有一个特殊的点，称为根节点(root), 它没有前驱结点只有后继结点
* (2) 除了跟结点之外的其他结点分为m(0<=m<=n)个互不相交的集合T<sub>0</sub>,T<sub>1</sub>,T<sub>2</sub>,...,T<sub>m-1</sub>，其中每个集合T<sub>i</sub>也是一个树形结构，称之为子树(Subtree)
<img src="https://img-blog.csdn.net/20161218200648524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>

这里我们需要明白树是递归定义，以下是一些树的常用术语:
* (1). 根结点: 根结点是没有双亲的结点，一棵树中最多有一个根结点
* (2). 孩子结点：一棵树中，一个结点的子树的根结点成为其孩子结点，如上体A的孩子结点有B.C.D
* (3). 父母结点：相对于孩子结点而言其前驱结点即为父母结点
* (4). 兄弟结点：拥有相同的父母结点的所有孩子结点叫做兄弟结点
* (5). 祖先结点：如果存在一条从根结点到结点Q的路径，而且结点P出现在这条路径上，那么P就是Q的祖先结点，而结点Q也成为P的子孙结点或者后代。如上图的E的祖先结点有A和B，而E则是A和B的子孙结点
* (6). 叶子结点：没有孩子结点的结点叫作叶子结点，如E,F，G等
* (7). 结点的度：指的是结点所拥有子树的棵树。如A的度为3，F的度为0，即叶子结点的度为0，而树的度则是树中各个结点度的最大值，如图中树的度为3
* (8). 树的层：又称结点的层，该属性反映结点处于树中的层次位置，我们约定根结点的层为1，如上图，A层为1，B层为2，E层为3
* (9). 树的高度（深度）：是指树中结点的最大层数，图中高度为3
* (10). 边：边表示从父母结点到孩子结点的连接线。

# 2. 二叉树的定义及其基本性质<br>
# 2.1 二叉树的定义：
```
关于二叉树的定义：二叉树(Binary Tree)是n(n>=0)个节点组成的有限集合，n=0时称为空二叉树；n>0的二叉树由一个根结点和两颗互不相交、分别称为左子树和右子树的子二叉树构成，二叉树也是递归定义的，在树中定义的度、层次等术语，同样适用于二叉树。
```

# 2.2 二叉树主要有以下5种基本形态:
<img src="https://img-blog.csdn.net/20161218201824994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>

# 2.3 二叉树的主要特性
* 性质1: 若根结点的层次为1，则二叉树第i层最多有2<sup>i-1</sup>(i>=1)个结点。
* 性质2：在高度为h的二叉树中，最多有2<sup>h</sup>-1个结点(h>=0)
* 性质3：满二叉树和完全二叉树
    一颗高度为h的满二叉树(Full Binary Tree)是具有2<sup>h</sup>-1个结点的二叉树。满二叉树的最大特点是每一层次的结点数都达到最大值。
    <img src="https://img-blog.csdn.net/20161218221545338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    对于完全二叉树，假设二叉树的深度为h, 除第h层外，其他各层(1~h-1)的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。
* 性质4：一颗具有n个结点的完全二叉树，对于序号为i(0<=i<n)的结点，有如下规则：
    * 若i=0, 则i为根结点，无父母结点；若i>0, 则i的父母结点序号为[(i-1)/2] (向下取整)
    * 若2i+1<n, 则i的左孩子结点序号为2i+1，否则i无左孩子.
    * 若2I+2>n, 则i的右孩子结点序号为2i+2，否则i无右孩子. 

# 3. 二叉树抽象数据类型及存储结构
## 3.1 二叉树抽象数据类型<br>
与链表、栈、队列等抽象数据类型相似，二叉树抽象数据类型也有插入、删除、查找等操作，同时二叉树还有4种遍历算法。
```
public interface Tree<T extends Comparable>{
    //判空
    boolean isEmpty();
    
    //二叉树结点个数
    int size();
    
    //返回二叉树的高度或深度
    int height();
    
    //先根次序遍历
    String preOrder();
    
    //中根次序遍历
    String inOrder();
    
    //后根次序遍历
    String postOrder();
    
    //层次遍历
    String levelOrder();
    
    //将data插入
    void insert(T data);
    
    //删除
    void remove(T data);
    
    //查找最大值
    T findMax();
    
    //查找最小值
    T findMin();
    
    //根据值找到结点
    BinaryNode findNode(T data);
    
    //是否包含某个值
    boolean contains(T data);
    
    //清空
    void clear();
}
```

## 3.2 二叉树存储结构<br>
关于二叉树的存储结构主要采用的是链式存储结构，至于顺序存储结构仅适用于完全二叉树或满二叉树。二叉树的链式存储结构主要有二叉链表和三叉链表两种。

### 3.2.1 二叉树的二叉链表存储结构<br>
二叉链表结构主要由一个数据域和两个分别指向左、右孩子的结点组成，结构如下：
```
BinaryNode(T data, BinaryNode<T> left, BinaryNode<T> right)
```
<img src="https://img-blog.csdn.net/20161218231724873?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
从图中可以看出，采用二叉链表存储结构，每个结点只存储了到其孩子结点的单向关系，而没有存储到父节点的关系，这样的话，每次要获取父节点时将消耗较多的时间，因为需要从root根结点开始查找，花费的时间是遍历部分二叉树的时间，而且与该结点的位置有关。

### 3.2.2 二叉树的三叉链表存储结构<br>
三叉链表主要是在二叉链表的基础上多添加了一个指向父节点的域，这样我们就存储了父节点与孩子结点的双向关系
```
ThreeNode(T data, ThreeNode<T> parent, ThreeNode<T> left, ThreeNode<T> right)
```
<img src="https://img-blog.csdn.net/20161218233740719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>

# 4 二叉树的设计与实现<br>
为了使二叉树的实现更有具体意思，我们将实现一种叫二叉查找树的数据结构，二叉查找树的特性是，对于树中的每个结点T(T可能是父节点), 它的左子树中所有项的值小于T中的值，而它的右子树中所有项的值都大于T中的值。这意味着该树所有的元素可以用某种规则进行排序(取决与Comparable接口的实现)。二叉查找树使用二叉链表存储结构实现，其结点BinaryNode声明如下:
```
public class BinaryNode<T extends Comparable> {
    public BinaryNode<T> left; //左结点
    
    public BinaryNode<T> right; //右结点
    
    public T data;
    
    public BinaryNode(T data, BinaryNode left, BinaryNode right){
        this.data = data;
        this.left = left;
        this.right = right;
    }
    
    public BinaryNode(T data){
        this(data,null,null);
    }
    
    /**
    * 判断是否为叶子结点
    */
    public boolean isLeaf(){
        return this.left==null && this.right==null;
    }
}
```

## 4.1 二叉查找树基本操作的设计与实现
### 4.1.1 二叉查找树的插入算法的设计与实现(递归）<br>
事实上对于二叉查找树的插入操作的设计是比较简单的，我们只要利用二叉查找树的特性(即对每个父结点，它的左子树中所有项的值小于T，右子树中所有项的值都大于T)，找到对应的插入位置即可，假设现在我们要插入data=4的结点，那么可以这样操作，沿着树查找(比较结点的数据与data的大小从而决定往左/右树继续前行)，如果找到data(4)，则什么也不做，否则将data插入到遍历的路径上的最后一个点，如下图所示：
<img src="https://img-blog.csdn.net/20161219224725132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
代码如下:
```
public void insert(T data){
    if(data==null)
        throw new RuntimeException()
    //插入操作
    root=insert(data,root);
}

/**
* 插入操作，递归实现
*/
private BinaryNode<T> insert(T data, BinaryNode<T> p){
    if(p==null){
        p=new BinaryNode<>(data,null,null);
    }
    
    //比较插入结点的值，决定向左子树还是右子树搜索
    int compareResult=data.compareTo(p.data)
    
    if(compareResult<0){//左
        p.left=insert(data,p.left);
    }else if(compareResult>0){//右
        p.right=insert(data,p.right);
    }else {
        ;//已有元素就没必要重复插入了
    }
    return p;
}
```

### 4.1.2 二叉查找树的删除算法的设计与实现(递归与非递归)<br>
对于二叉树来说，删除是一种比较麻烦的操作，因为涉及到了多种情况(假设要删除的结点为q,其父母结点为p):
* (1). 如果要删除的结点q恰好是叶子结点，那么它可以立即被删除
* (2). 如果要删除的结点q拥有一个孩子结点，则应该调整要被删除的父节点(p.left或p.right)指向被删除结点的孩子结点(q.left或q.right)
* (3). 如果要删除的结点q拥有两个孩子结点，则删除策略是用q的右子树的最小的数据替代要被删除结点的数据，并递归删除用于替换的结点(此时该结点已为空)，此时二叉查找树的结构并不会被打乱，其特性仍旧生效。采用这样策略的主要原因是右子树的最小结点的数据替换要被删除的结点后，可以满足维持二叉查找树的结构和特性，又因为右子树最小结点不可能有左孩子，删除起来也相对简单些。
<img src="https://img-blog.csdn.net/20161220082105134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>

删除操作的实现，也是递归实现，其中的findMin方法是查找二叉查找树中的最小值:
```
public void remove(T data){
    if(data==null)
        throw new RuntimeException();
    //删除结点
    root=remove(data,root);
}

/**
* 分3种情况
* 1.删除叶子结点(也就是没有孩子结点)
* 2.删除拥有一个孩子结点的结点(可能是左孩子也可能是右孩子)
* 3.删除拥有两个孩子结点的结点
*/
private BinaryNode<T> remove(T data, BinarayNode<T> p){
    //没有找到要删除的元素，递归结束
    if(p==null){
        return p;
    }
    
    int compareResult=data.compareTo(p.data);
    
    if(compareResult<0){//左边查找删除结点
        p.left=remove(data,p.left);
    }else if(compareResult>0){
        p.right=remove(data,p.right);
    }else if(p.left!=null&&p.right!=null){//已找到结点并判断是否有两个字结点
        //中继替换，找到右子树中最小的元素并替换需要删除的元素值
        p.data = findMin(p.right).data;
        //移除用于替换的结点
        p.right=remove(p.data,p.right);
    }else{
        //拥有一个孩子结点的结点的叶子结点的情况
        p=(p.left!=null)?pleft:p.right;
    }
    
    return p;//返回该结点
}
```

### 4.1.3 二叉查找树的最大和最小值的查找算法与实现（递归）<br>
二叉查找树中的findMin和findMax分别返回的是树中的最小值和最大值，对于findMin(),则需要从根结点开始并且只要有左孩子就向左进行即可，其终点即为最小值的元素；findMax也类似，代码如下:
```
public T findMin(){
    if(isEmpty())
        throw new EmptyTreeException();
    
    return findMin(root).data;
}

public T findMax(){
    if(isEmpty())
        throw new EmptyTreeException();
    
    return findMax(root).data;
}

/*
*查找最小值结点
*/
private BinaryNode<T> findMin(BinaryNode<T> p){
    if(p==null)//结束条件
        return null;
    else if(p.left == null) //如果没有左结点，那么就是最小的
        return p;
    return findMin(p.left)
}

/*
*查找最大值结点
*/
private BinaryNode<T> findMax(BinaryNode<T> p){
    if(p==null)//结束条件
        return null;
    else if(p.right == null) 
        return p;
    return findMin(p.right)
}
```

### 4.1.4 二叉查找树的深度(height)和大小(size)计算的设计与实现(递归)<br>
计算深度
```
public int height(){
    return height(root)
}

private int height(BinaryNode<T> subtree){
    if(subtree==null){
        return 0;
    }else {
        int l=height(subtree.left);
        int r=height(subtree.right)
        return (l>r)?(l+1):(r+1); //返回并加上当前层
    }
}

```
计算大小
```
public int size(){
    return size(root)
}

private int size(BinaryNode<T> subtree){
    if(subtree==null)
        return 0;
    else
    {
    //对比汉诺塔: H(n)=H(n-1) + 1 + H(n-1)
    return size(subtree.left) + 1 + size(subtree.right)
    }
}
```

## 4.2 二叉查找树的遍历算法
二叉树的遍历规则主要有四种，先根次序遍历，中根次序遍历，后根次序遍历以及层次遍历。

### 4.2.1 先根次序遍历算法的实现
先根次数遍历，其访问规则是先遍历根结点，再遍历左子树，最后遍历右子树。
<img src="https://img-blog.csdn.net/20161220224702494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
从图可知，先根遍历每次总是先访问根结点，再访问左子树，最后访问右子树，而对于一个复杂的树，可以可以先将其简化为三个结点的树，然后解除该子树的顺序，再求解其上层的子树，这样整棵树的遍历顺序求出来了，事实上这里我们又再次运用递归思维，因此在程序中也可以使用递归算法实现先根次序遍历算法如下:
```
public String preOrder(){
    String sb=preOrder(root);
    if(sb.length()>0)
    {
        //去掉尾部","号
        sb=sb.substring(0,sb.length()-1);
    }
    
    return sb;  
}

/**
*先根遍历
*/
public String preOrder(BinaryNode<T> subtree){
    StringBuffer sb=new StringBuffer();
    if(subtree!=null){//递归结束条件
        //先访问根结点
        sb.append(subtree.data+",");
        //遍历左子树
        sb.append(preOrder(subtree.left));
        //遍历右子树
        sb.append(preOrder(subtree.right));
    }
    return sb.ToString();
}
```

### 4.2.2 中根次序遍历算法的实现<br>
中根遍历算法的规则是，先遍历左子树，再遍历根结点，最后遍历右子树。
<img src="https://img-blog.csdn.net/20161221091232138?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
```
public String inOrder(){
    String sb=inOrder(root)
    if(sb.length()>0){
        //去掉尾部","号
        sb=sb.substring(0,sb.length()-1);
    }
    return sb;
}

/**
*中根遍历
*/
public String inOrder(BinaryNode<T> substree){
    StingBuffer sb= new StringBuffer();
    if(subtree!=null){//递归结束条件
        //先遍历左子树
        sb.append(inOrder(subtree.left));
        //再遍历根结点
        sb.append(subtree.data+",");
        //最后遍历右子树
        sb.append(inOrder(subtree.right));
    }
    return sb.toString();
}
```

### 4.2.3 后根次序遍历算法的实现<br>
后根次序遍历的算法规则是，先访问左子树，再访问右子树，最后访问根结点.
<img src="https://img-blog.csdn.net/20161221091252773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
```
public String postOrder(){
    String sb=postOrder(root);
    if(sb.length()>0){
        //去掉尾部","号
        sb=sb.substring(0,sb.length()-1);
    }
    return sb;
}

/**
*后根遍历
*/
public String postOrder(BinaryNode<T> subtree){
    StringBuffer sb=new StringBuffer();
    if(subtree!=null){//递归结束条件
        //先遍历左子树
        sb.append(postOrder(subtree.left));
        //再遍历右子树
        sb.append(postOrder(subtree.right));
        //最后遍历根结点
        sb.append(subtree.data+",");
    }
    return sb.toString();
}
```

### 4.2.4 层次遍历算法的实现<br>
二叉查找树的层次遍历特性就是兄弟优先访问，两个兄弟结点的访问顺序是先左后右的。同样他们的后代结点的访问次数也是先左后右，左兄弟的所有孩子结点一定优先右兄弟的孩子访问。对于二叉查找树的层次遍历算法，我们需要明确如何解决以下存在的问题(假设p从根结点开始访问):
* p点如何到达其兄弟结点？ B->C
* p点如何到达它同层下一个结点(非兄弟结点)? D->E
* p点如何在访问完当前层的最后一个结点时，进入下一层的第一个结点？C->D
<img src="https://img-blog.csdn.net/20161221094136274?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
很显然，我们现在遇到的问题跟前面非递归算法遍历的问题有些类似，也就是二叉链表的本身根本无法满足以上任意一个问题，因为从B到C，从D到E，从C到D根本没有桥梁，此时肯定得借助第三方容器来满足需求，那个这个容器该如何选呢？该容器必须告诉我们下一个访问结点是谁？层次遍历的规则是兄弟优先，从左往右，因此，在访问时，必须先将当前正在访问的结点P的左右孩子依次放入容器，如P=C时，E、H必须已在栈中，而且先进如必须先访问，即先进E再进H，然后先访问E再访问H，显然该容器必须满足"先进先出"的原则，那也就是队列了，这里我们选择LinkedQueue队列，层次遍历算法描述如下：
p点从根结点开始访问，设一个空队列，当前p结点不为空时，重复以下操作：
* 1. 访问p结点，将p结点的左右孩子依次入队
* 2. 使p指向一个出队结点，重复1的操作，直到队列为空。
过程如下图：
<img src="https://img-blog.csdn.net/20161222064858766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
算法实现如下:
```
/**
*层次遍历
*/
public String levelOrder(){
    //存放需要遍历的结点，左结点一定优先右结点遍历
    LinkedQueue<BinaryNode<T> queue=new LinkedQueue<>();
    StringBuffer sb=new StringBuffer();
    BinaryNode<T> p=this.root;
    
    while(p!=null){
        //记录经过的结点
        sb.append(p.data);
        
        //先按层次遍历结点，左结点一定在右结点之前访问
        if(p.left!=null){
            //左孩子结点入队
            queue.add(p.left);
        }
        
        if(p.left!=null){
            //右孩子结点入队
            queue.add(p.right);
        }
        
        访问下一个结点
        p=queue.poll();
    }
    return sb.toString();
}
```

# 5 完全二叉树的构造与实现<br>
TBD
