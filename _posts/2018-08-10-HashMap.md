---
layout:     post
title:      java中哈希表及其应用详解
subtitle:   Java数据结构与算法(八)
date:       2018-08-10
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

```
public class MyHashMap<K, V> {

	private static final double LOAD_FACTOR = 0.75;
	private static final int DEFAULT_CAPACITY = 16;

	private Entry[] table;
	private int elemCount;

	class Entry<K, V> {

		private int hash;
		private K key;
		private V value;
		private Entry<K, V> next;

		public Entry(K key, V value) {
			this.key = key;
			this.value = value;
			this.next = null;
		}

		public Entry(int hash, K key, V value, Entry<K, V> next) {
			this.hash = hash;
			this.key = key;
			this.value = value;
			this.next = next;
		}

		public void setHash(int newHash) {
			hash = newHash;
		}

		public void setKey(K newKey) {
			key = newKey;
		}

		public void setValue(V newValue) {
			value = newValue;
		}

		public void setNext(Entry<K, V> newEntry) {
			next = newEntry;
		}

		public int getHash() {
			return hash;
		}

		public K getKey() {
			return key;
		}

		public V getValue() {
			return value;
		}

		public Entry<K, V> getNext() {
			return next;
		}
	}

	public MyHashMap() {
		table = new Entry[DEFAULT_CAPACITY];
		elemCount = 0;
	}

	public MyHashMap(int capacity) {
		table = new Entry[capacity];
		elemCount = 0;
	}

	public V put(K key, V value) {

		int hash = (key == null) ? 0 : hash(key.hashCode());
		int i = indexFor(hash, table.length);
		for (Entry<K, V> e = table[i]; e != null; e = e.getNext()) {
			if (e.getKey().equals(key)) {
				V oldValue = e.getValue();
				e.setValue(value);
				return oldValue;
			}
		}
		addEntry(hash, key, value, i);
		return null;
	}

	public V get(K key) {

		int hash = (key == null) ? 0 : hash(key.hashCode());
		int i = indexFor(hash, table.length);
		for (Entry<K, V> e = table[i]; e != null; e = e.getNext()) {
			if (e.getKey().equals(key)) {
				return e.getValue();
			}
		}
		return null;
	}

	public V remove(K key) {
		int hash = (key == null) ? 0 : hash(key.hashCode());
		int i = indexFor(hash, table.length);

		Entry<K, V> prev = table[i];
		Entry<K, V> e = prev;

		while (e != null) {
			if (e.getKey().equals(key)) {
				if (prev == e) {
					table[i] = e.getNext();
				} else {
					prev.setNext(e.getNext());
				}
				elemCount--;
				return e.getValue();
			}
			prev = e;
			e = e.getNext();
		}
		return null;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < table.length; i++) {
			if (table[i] != null) {
				sb.append(i + ": ");
				Entry<K, V> curr = table[i];
				while (curr != null) {
					sb.append("(" + curr.getKey() + ", " + curr.getValue() + ") ");
					curr = curr.getNext();
				}
				sb.append('\n');
			}
		}
		return sb.toString();
	}

	private int indexFor(int h, int length) {
		return h & (length - 1);
	}

	private void addEntry(int hash, K key, V value, int bucketIndex) {
		Entry<K, V> e = table[bucketIndex];
		table[bucketIndex] = new Entry<K, V>(hash, key, value, e);
		elemCount++;
		if (elemCount >= LOAD_FACTOR * table.length)
			resize();
	}

	private int hash(int h) {
		h ^= (h >>> 20) ^ (h >>> 12);
		h ^= (h >>> 7) ^ (h >>> 4);
		return (h < 0) ? h * -1 : h;
	}

	private void resize() {
		Entry[] newTable = new Entry[table.length * 2];

		for (int j = 0; j < table.length; j++) {
			Entry<K, V> e = table[j];

			if (e != null) {
				while (e != null) {
					Entry<K, V> next = e.getNext();
					int i = indexFor(e.getHash(), newTable.length);
					e.setNext(newTable[i]);
					newTable[i] = e;
					e = next;
				}
			}
		}
		table = newTable;
	}

	private int getHash(K key) {
		char array[] = String.valueOf(key).toCharArray();
		int hash = 0;
		for (char temp : array) {
			hash = hash * 31 + temp;
		}
		return hash;
	}

	public static boolean equal(String left, String right) {
		int n = left.length();
		if (n == right.length()) {
			char v1[] = left.toCharArray();
			char v2[] = right.toCharArray();
			int i = 0;
			while (n-- != 0) {
				if (v1[i] != v2[i])
					return false;
				i++;
			}
			return true;
		}
		return false;
	}

}

```
