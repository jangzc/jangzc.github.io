---
layout:     post
title:      java中哈希表及其应用详解
subtitle:   Java数据结构与算法(八)
date:       2018-08-10
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

* 哈希算法，是一类算法
* 哈希表(Hash Table), 一种数据结构
* 哈希函数，是支撑哈希表的一类函数
* Map是映射的意思，在Java中Map表示一种把K映射到V的数据结构
* HashMap, 是Java中用哈希表实现的一种Map

# 1. Hash算法
# 1.1 是什么？
```
这类算法接受任意长度的二进制输入值，对输入值做换算(切碎)，最终给出固定长度的二进制输出值
```
以更好理解的方式来说，Hash算法是摘要算法：它从不同的输入中，通过一些计算摘取出来一段输出结果，且这个值可以用以区分输入数据。
所以，MD5可能是最著名的一种Hash算法了。

# 1.2 有什么用？
* 1. 信息安全领域
Hash算法可用作加密算法。<br>
如文件检验：通过对文件摘要，可以得到文件的数字指纹。
* 2. 数据结构领域
Hash算法通常还可以用作快速查找.
根据Hash函数我们可以实现一种叫做哈希表的数据结构。这种结构可以使得我们可以实现对数据快速的"存"和"取"

# 2. 哈希表
## 2.1 什么是哈希表？
首先想一个问题：我们之前是如何在数据结构中做查找的呢？<br>
* 线性表、树：在线性表、树这些结构中，记录在结构中的相对位置是随机的，和记录的关键字之间不存在确定关系。因此，在结构中查找时需要进行一系列和关键字的比较，即这一类查找方法建立在比较的基础上。在顺序查找时，比较的结果为"="与"!="2种可能；在折半查找、二叉排序操作和B-树查找时，比较的结果为"<","=",">"3种可能。此时，查找的效率依赖于查找过程中所进行的比较次数。<br>
* 引出Hash表：理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的关系f,使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系f找到给定值K的像f(K)。若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上，反正在这个位置上没有记录。因此，不需要比较便可直接取得所查记录。在此，我们称这个对应关系f为:哈希函数，按这个思想建立的映射关系表为：哈希表。<br>

哈希函数的特点：
* 1. 灵活
	



```
public class MyHashMap<K, V> {

	private static final double LOAD_FACTOR = 0.75;
	private static final int DEFAULT_CAPACITY = 16;

	private Entry[] table;
	private int elemCount;

	class Entry<K, V> {

		private int hash;
		private K key;
		private V value;
		private Entry<K, V> next;

		public Entry(K key, V value) {
			this.key = key;
			this.value = value;
			this.next = null;
		}

		public Entry(int hash, K key, V value, Entry<K, V> next) {
			this.hash = hash;
			this.key = key;
			this.value = value;
			this.next = next;
		}

		public void setHash(int newHash) {
			hash = newHash;
		}

		public void setKey(K newKey) {
			key = newKey;
		}

		public void setValue(V newValue) {
			value = newValue;
		}

		public void setNext(Entry<K, V> newEntry) {
			next = newEntry;
		}

		public int getHash() {
			return hash;
		}

		public K getKey() {
			return key;
		}

		public V getValue() {
			return value;
		}

		public Entry<K, V> getNext() {
			return next;
		}
	}

	public MyHashMap() {
		table = new Entry[DEFAULT_CAPACITY];
		elemCount = 0;
	}

	public MyHashMap(int capacity) {
		table = new Entry[capacity];
		elemCount = 0;
	}

	public V put(K key, V value) {

		int hash = (key == null) ? 0 : hash(key.hashCode());
		int i = indexFor(hash, table.length);
		for (Entry<K, V> e = table[i]; e != null; e = e.getNext()) {
			if (e.getKey().equals(key)) {
				V oldValue = e.getValue();
				e.setValue(value);
				return oldValue;
			}
		}
		addEntry(hash, key, value, i);
		return null;
	}

	public V get(K key) {

		int hash = (key == null) ? 0 : hash(key.hashCode());
		int i = indexFor(hash, table.length);
		for (Entry<K, V> e = table[i]; e != null; e = e.getNext()) {
			if (e.getKey().equals(key)) {
				return e.getValue();
			}
		}
		return null;
	}

	public V remove(K key) {
		int hash = (key == null) ? 0 : hash(key.hashCode());
		int i = indexFor(hash, table.length);

		Entry<K, V> prev = table[i];
		Entry<K, V> e = prev;

		while (e != null) {
			if (e.getKey().equals(key)) {
				if (prev == e) {
					table[i] = e.getNext();
				} else {
					prev.setNext(e.getNext());
				}
				elemCount--;
				return e.getValue();
			}
			prev = e;
			e = e.getNext();
		}
		return null;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < table.length; i++) {
			if (table[i] != null) {
				sb.append(i + ": ");
				Entry<K, V> curr = table[i];
				while (curr != null) {
					sb.append("(" + curr.getKey() + ", " + curr.getValue() + ") ");
					curr = curr.getNext();
				}
				sb.append('\n');
			}
		}
		return sb.toString();
	}

	private int indexFor(int h, int length) {
		return h & (length - 1);
	}

	private void addEntry(int hash, K key, V value, int bucketIndex) {
		Entry<K, V> e = table[bucketIndex];
		table[bucketIndex] = new Entry<K, V>(hash, key, value, e);
		elemCount++;
		if (elemCount >= LOAD_FACTOR * table.length)
			resize();
	}

	private int hash(int h) {
		h ^= (h >>> 20) ^ (h >>> 12);
		h ^= (h >>> 7) ^ (h >>> 4);
		return (h < 0) ? h * -1 : h;
	}

	private void resize() {
		Entry[] newTable = new Entry[table.length * 2];

		for (int j = 0; j < table.length; j++) {
			Entry<K, V> e = table[j];

			if (e != null) {
				while (e != null) {
					Entry<K, V> next = e.getNext();
					int i = indexFor(e.getHash(), newTable.length);
					e.setNext(newTable[i]);
					newTable[i] = e;
					e = next;
				}
			}
		}
		table = newTable;
	}

	private int getHash(K key) {
		char array[] = String.valueOf(key).toCharArray();
		int hash = 0;
		for (char temp : array) {
			hash = hash * 31 + temp;
		}
		return hash;
	}

	public static boolean equal(String left, String right) {
		int n = left.length();
		if (n == right.length()) {
			char v1[] = left.toCharArray();
			char v2[] = right.toCharArray();
			int i = 0;
			while (n-- != 0) {
				if (v1[i] != v2[i])
					return false;
				i++;
			}
			return true;
		}
		return false;
	}

}

```
