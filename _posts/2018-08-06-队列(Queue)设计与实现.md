---
layout:     post
title:      Java数据结构与算法(六)
subtitle:   队列(Queue)设计与实现
date:       2018-08-06
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 6. 队列的抽象数据类型<br>
队列同样是一种特殊的线性表，其插入和删除的操作分别在表的两端进行，队列的特点就是先进先出。我们把向队列中插入元素的过程称为入列，删除过程称为出列，并把允许入队的一端称为队尾，允许出列的一端称为队头，没有任何元素的队列则称为空队列。

## 6.1 顺序队列的设计与实现<br>
关于顺序队列(底层都是利用数组作为容器)的实现，我们将采用顺序循环队列的结构来实现，在给出实现方案之前，先来分析一下为什么不直接使用顺序表作为底层容器来实现。实际上采用顺序表实现队列时，入列操作直接执行顺序表尾部插入操作，其时间复杂度为O(1), 出列操作直接执行顺序表头部删除操作，其时间复杂度为O(n),主要用于移动元素，效率低，既然如此，我们就把出队的时间复杂度降为O(1)即可，为此在顺序表中添加一个头指向下标front和尾指向下标，出列和入列时只要改变front,rear的下标指向取值即可，此时无需移动元素，因此出列的时间复杂度也就变为O(1)。<br>

<img src="https://img-blog.csdn.net/20161203175132047"/>
空队列时front和rear都为-1, 同时可以发现，虽然通过给顺序表添加front和rear变量记录下标后使得出列操作的时间复杂度降为O(1),但是却出现了另外一个严重的问题，那就是空间浪费，从图中的(d)和(e)操作可以发现，20和30出列后，遗留下来的空间并没有被重新利用，反而是空着，所以导致执行(f)操作时，出现队列已满的假象，这种假象称之为假溢出，之所以出现这样的假溢出是因为顺序表队列的存储单元没有重复利用机制，而解决该问题的最合适的方式就是将顺序队列设计为循环结构，解析来我们就通过循坏顺序表来实现顺序队列。<br>

顺序循环队列就是将顺序队列设计为在逻辑结构上首尾相接的循环结构，这样我们就可以重复利用存储单元，过程如下：
<img src="https://img-blog.csdn.net/20161203194723292"/>

简单分析一下:
其中采用循环结构的顺序表，可以循坏利用存储单元，因此有如下计算关系(其中size为队列长度):
```
//其中front、rear的下标的取值范围是0~size-1, 不会造成假溢出.
front=(front+1)%size;
rear=(rear+1)%size;
```
* 1. front为队头元素的下标，rear则指向下一个入队元素的下标
* 2. 当front==rear时，我们约定队伍为空
* 3. 出队操作改变front下标指向，入队操作改变rear下标指向，size代表队列容量
* 4. 约定队列满的条件为front==(rear+1)%size, 注意此时队列中仍有一个空的位置，此处留一个空位主要用于避免与队列空的条件front==rear相同
* 5. 队列内部的数组可扩容，并按照原来队列的次序复制元素数组

### 6.1.1 入队add方法<br>
```
/**
* data 入队，添加成功返回true, 否则返回false, 可扩容
*/
public boolean add(T data) {
    //判断是否满队
    if(this.front==(this.rear+1)%this.elementData.length){
        ensureCapacity(elementData.length*2+1)
    }
    //添加data
    elementData[this.rear]=data;
    //更新rear指向下一个空元素的位置
    this.rear=(this.rear+1)%elementData.length;
    size++;
    return true;
}
```
在add方法中我们判断队列是否满，如果队列满，则扩容，方法如下:
```
public void ensureCapacity(int capacity){
    //如果需要扩展的容量比现在数组的容量还小，则无需扩容
    if(capacity<size)
        return;
    
    T[] old = elementData;
    elementData = (T[]) new Object[capacity];
    int j=0;
    //复制元素
    for(int i=this.front; i!=this.rear; i=(i+1)%old.length){
        elementData[j++] = old[i];
    }
    //恢复front,rear指向
    this.front=0;
    this.rear=j;
}
```
这个方法比较简单，主要创建一个新容量的数组，并把就数组中的元素复制到新数组中，这里唯一要注意的是，判断旧数组是否复制完的条件为i!=this.rear，同时循环的自增条件为i=(i+1)%old.length。扩容后直接通过rear添加新元素，最后更新rear指向下一个入队新元素。

### 6.1.2 出队操作pool的实现<br>
```
/**
*出队，执行删除操作，返回队头元素，若队列为空，返回null
*/
public T poll(){
    T temp=this.elementData[this.front];
    this.front=(this.front+1)%this.elementData.length;
    size--;
    return temp;
}
```
出队操作相对简单些，直接存储要删除元素的数据，并更新front的值，最后返回删除元素。

## 6.2 链式队列的设计与实现<br>
分析完顺序队列，我们接着开口链式队列的设计和实现，对于链式队列，将使用带头指针front和尾指针rear的单链表实现，front直接指向队头的第一个元素, rear指向队尾的最后一个元素，结构如下：
<img src="https://img-blog.csdn.net/20161203224607173"/>

之所以选择单链表(带头尾指针)而不采用循坏双链表或者双链表，主要是双链表的空间开销(空间复杂度，多了前继指针)相对单链表来说大量不少，而单链表只要新增头指针和尾指针就可以轻松实现在常数时间内O(1)访问头尾结点。<br>

链式队列设计：
* 1. 以上述的图为例，分别设置front和rear指向队头结点和队尾结点，使用单链表的头尾访问时间复杂度为O(1).
* 2. 设置初始化队列，使用front=rear=null, 并且约定条件front==null&&rear==null成立时，队列为空
* 3. 出队操作时，若队列不为空获取队头结点元素，并删除队头结点元素，更新front指针的指向为front=front.next
* 4. 入队操作时，使插入元素的结点在rear之后并更新rear指针指向新插入元素
* 5. 当第一个元素入队或者最后一个元素出队时，同时更新front指针和rear指针的指向
<img src="https://img-blog.csdn.net/20161203232233493"/>

## 6.3 队列应用的简单举例
* 1. 模拟现实世界中的队列，如售票柜台的队列以及其他先到先服务的场景
* 2. 计算客户在呼叫中心等待的时间
* 3. 异步数据的传输(文件输入输出、管道、嵌套字)
* 4. 操作系统中的优先级任务执行
* 5. 短信群体发送应用的发布订阅模式


