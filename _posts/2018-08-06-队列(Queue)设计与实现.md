---
layout:     post
title:      Java数据结构与算法(六)
subtitle:   队列(Queue)设计与实现
date:       2018-08-06
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 6. 队列的抽象数据类型<br>
队列同样是一种特殊的线性表，其插入和删除的操作分别在表的两端进行，队列的特点就是先进先出。我们把向队列中插入元素的过程称为入列，删除过程称为出列，并把允许入队的一端称为队尾，允许出列的一端称为队头，没有任何元素的队列则称为空队列。

## 6.1 顺序队列的设计与实现<br>
关于顺序队列(底层都是利用数组作为容器)的实现，我们将采用顺序循环队列的结构来实现，在给出实现方案之前，先来分析一下为什么不直接使用顺序表作为底层容器来实现。实际上采用顺序表实现队列时，入列操作直接执行顺序表尾部插入操作，其时间复杂度为O(1), 出列操作直接执行顺序表头部删除操作，其时间复杂度为O(n),主要用于移动元素，效率低，既然如此，我们就把出队的时间复杂度降为O(1)即可，为此在顺序表中添加一个头指向下标front和尾指向下标，出列和入列时只要改变front,rear的下标指向取值即可，此时无需移动元素，因此出列的时间复杂度也就变为O(1)。<br>

<img src="https://img-blog.csdn.net/20161203175132047"/>
空队列时front和rear都为-1, 同时可以发现，虽然通过给顺序表添加front和rear变量记录下标后使得出列操作的时间复杂度降为O(1),但是却出现了另外一个严重的问题，那就是空间浪费，从图中的(d)和(e)操作可以发现，20和30出列后，遗留下来的空间并没有被重新利用，反而是空着，所以导致执行(f)操作时，出现队列已满的假象，这种假象称之为假溢出，之所以出现这样的假溢出是因为顺序表队列的存储单元没有重复利用机制，而解决该问题的最合适的方式就是将顺序队列设计为循环结构，解析来我们就通过循坏顺序表来实现顺序队列。<br>

顺序循环队列就是将顺序队列设计为在逻辑结构上首尾相接的循环结构，这样我们就可以重复利用存储单元，过程如下：
<img src="https://img-blog.csdn.net/20161203194723292"/>

简单分析一下:
其中采用循环结构的顺序表，可以循坏利用存储单元，因此有如下计算关系(其中size为队列长度):
```
//其中front、rear的下标的取值范围是0~size-1, 不会造成假溢出.
front=(front+1)%size;
rear=(rear+1)%size;
```
* 1. front为队头元素的下标，rear则指向下一个入队元素的下标
* 2. 当front==rear时，我们约定队伍为空
* 3. 出队操作改变front下标指向，入队操作改变rear下标指向，size代表队列容量
* 4. 约定队列满的条件为front==(rear+1)%size, 注意此时队列中仍有一个空的位置，此处留一个空位主要用于避免与队列空的条件front==rear相同
* 5. 队列内部的数组可扩容，并按照原来队列的次序复制元素数组

## 6.2 入队add方法<br>
```
/**
* data 入队，添加成功返回true, 否则返回false, 可扩容
*/
public boolean add(T data) {
    //判断是否满队
    if(this.front==(this.rear+1)%this.elementData.length){
        ensureCapacity(elementData.length*2+1)
    }
    //添加data
    elementData[this.rear]=data;
    //更新rear指向下一个空元素的位置
    this.rear=(this.rear+1)%elementData.length;
    size++;
    return true;
}
```
在add方法中我们判断队列是否满，如果队列满，则扩容，方法如下:
```
public void ensureCapacity(int capacity){
    //如果需要扩展的容量比现在数组的容量还小，则无需扩容
    if(capacity<size)
        return;
    
    T[] old = elementData;
    elementData = (T[]) new Object[capacity];
    int j=0;
    //复制元素
    for(int i=this.front; i!=this.rear; i=(i+1)%old.length){
        elementData[j++] = old[i];
    }
    //恢复front,rear指向
    this.front=0;
    this.rear=j;
}
```


