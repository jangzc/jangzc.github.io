---
layout:     post
title:      顺序表和链表
subtitle:   java语言
date:       2018-08-02
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 1. 线性表抽象数据类型：
## 线性表定义：
线性表是由n(n>=0)个类型相同的数据元素a<sub>0</sub>,a<sub>1</sub>,...a<sub>n-1</sub>组成的有限的序列，在数学中记作(a<sub>0</sub>,a<sub>1</sub>,...,a<sub>n-1</sub>), 其中a<sub>i</sub>的数据类型可以是基本数据类型(int, float等)、字符或类。n代表线性表的元素个数，也称其为长度(Length)。若n=0, 则为空表；若n>0，则a<sub>i</sub>(0<i<n-1)有且仅有一个前驱(Predecessor)元素a<sub>i-1</sub>和一个后继(Successor)元素a<sub>i+1</sub>，a<sub>0</sub>没有前驱元素，a<sub>i</sub>没有后继元素

# 2. 线性表的顺序存储设计与实现（顺序表）
## 2.1 数序存储结构的设计原理

顺序存储结构底层是利用数组来实现的，而数组可以存储具有相同数据类型的元素集合，如int,float或者自定义类型等，当我们创建一个数组时，OS会为该数据分配一块连续的内存卡块，这也就意味着数组中的每个存储单元的地址都是连续的，因此只要知道了数据的起始内存地址就可以通过简单的乘法和加法计算出数组中第n-1个存储单元的内存地址。
 
为了访问一个数组元素，该元素的内存地址需要计算其距离数组基地址的偏移量，即用一个乘法计算偏移量然后加上基地址，就可以获得数组中某个元素的内存地址。其中c代表的是元素数据类型的存储空间大小，而序号则为数组的下标索引。整个过程需要一次乘法和一个加法运算，因为这两个操作的执行时间是常数时间，所以我们可以认为数组访问操作能在常数时间内完成，即时间复杂度为O(1)，这种存取任何一个元素的时间复杂度为O(1)的数据结构称之为随机存取结构。

顺序表的定义：
线性表的顺序存储结构称之为顺序表(Sequential List), 它使用一维数据依次存放从a<sub>0</sub>到a<sub>n-1</sub>的数据元素(a<sub>0</sub>,a<sub>1</sub>,...,a<sub>n-1</sub>, 将a<sub>i</sub>(0<i<n-1)存放在数组的第i个元素，使得a<sub>i</sub>与其前驱a<sub>i-1</sub>及后继a<sub>i+1</sub>的存储位置相邻，因此数据元素在内存的物理存储次序反映了线性表数据元素之间的逻辑顺序
 
## 2.2 顺序存储结构的实现
* get(int index)实现分析 
  从顺序表中获取值是一种相当简单的操作并且效率很高，这是由于顺序表内部采用了数组作为存储数据的容器。因此只要根据传递的索引值，然后直接获取数组中对应的下标的值即可，代码如下：
```
public T get(int index){
    if (index>=0 && index<this.length)
        return (T) this.table[index];
    return null;
}
```

* set(int index, T data)实现分析
  在顺序表中替换值也是非常高效和简单的，只要根据传递的索引值index找到需要替换的元素，然后把对应元素替换成传递的data值即可，代码如下：
```
public T set(int index, T data) {
    if (index > 0 && index < this.length && data != null) {
        T old = (T) this.table[index];
        this.table[index] = data;
        return old;
    }
    return null;
}
```

* add(int index, T data)实现分析
  在顺序表中执行插入操作时，如果其内部数组的容量尚未达到最大值时，可以归结为两种情况，一种是在头部插入或者中间插入，这种情况下需要移动数组中的数据元素，效率较低，另一种是在尾部插入，无需移动数组中的元素，效率高。但是当顺序表内部数组的容量已经达到最大值无法插入时，则需要申请另一个更大容量的数组并复制全部数组元素到新的数组，这样的时间和空间开销是比较大的，也就导致了效率更为糟糕了。因此在插入频繁的场景下，顺序表的插入操作并不是理想的选择。
```
public boolean add(int index, T data){
    if(data == null)
        return false;
    
    //插入下标的容错判断，插入在最前面
    if(index<0)
        index=0;
    
    //插入下标的容错判断，插入在最后面
    if(index>this.length)
        index = this.length;
    
    //判断数组是否已满
    if(this.length==table.length){
        //把原数组赋值给临时数组
        Object[] temp = this.table;
        
        //对原来的数组进行成倍的扩容，并把原数组的元素复制到新数组
        this.table = new Object[temp.length*2];
        
        //先把原数组下标从0到index-1(即插入位置的前一个位置)复制到新数组
        for (int i=0; i<index; i++){
            this.table[i] = temp[i]
        }
    }
    
    //从原数组的最后一个元素开始直到index位置，都往后一个位置
    //最终腾出来的位置就是插入元素的位置了
    for (int j=this.length-1; j>=index; j--){
        this.table[j + 1] = this.table[j];
    }
    
    //插入新值
    this.table[index] = data;
    
    //长度加一
    this.length++;
    
    //插入成功
    return true;
}
```
