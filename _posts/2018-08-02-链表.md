---
layout:     post
title:      Java数据结构与算法(二)
subtitle:   顺序表与链表
date:       2018-08-02
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 3. 线性表的链式存储设计与实现（链表）
## 3.1 链表的链式存储设计原理
通过前面对线性顺序表的分析，我们知道当创建顺序表时必须分配一块连续的内存存储空间，而当顺序表内部数组的容量不足时，则必须创建一个新的数组，然后把原数组的元素复制到新的数组中，这将浪费大量的时间。而在插入或删除元素时，可能需要移动数组中的元素，这也将消耗一定的时间。鉴于这种种原因，于是链表就出场了，链表在初始化时仅需要分配一个元素的存储空间，并且插入和删除新的元素也相当便捷，同时链表在内存分配上可以是不连续的内存，也不需要做任何内存复制和重新分配的操作，由此看来顺序表的缺点在链表中都变成了优势，实际上也是如此，当然链表也有缺点，主要是在访问单个元素的时间开销上。<br>
线性链表的存储结构是用若干个地址分散的存储单元存放数据元素的，逻辑上相邻的数据元素在物理位置上不一定相邻，因此每个存储单元中都会有一个地址指向域，这个地址指向域指明其后续元素的位置。在链表中存储的单元称为结点(Node), 一个结点至少包含了数据域和地址域，其中数据域用于存储数据，而地址域用于存储前驱或后继元素的地址。前面我们说过链表的插入和删除都相当便捷，这是由于链表的结点存储空间是在插入或者删除过程中动态申请和释放的，不需要预先给单链表分配存储空间的，从来避免了顺序表因存储空间不足需要扩充空间和复制元素的过程，提高了运行效率和存储空间的利用率

## 3.2 单链表的存储结构实现分析
最基本的存储单元Node代码如下：
```
/**
 * 单向链表结点
 */
public class Node<T> {
    public T data; //数据域
    public Node<T> next; //地址域
    
    public Node(T data){
        this.data = data;
    }
    
    public Node(T data, Node<T> next){
        this.data = data;
        this.next = next;
    }
}
```

创建一个单链表SingleLinkedList，声明一个单链表的头结点head, 代表链表的开始位置，如下:
```
public class SingleLinkedList<T> {
    protected Node<T> head; //带数据头结点
    
    public SingleLinkedList(Node<T> head){
        this.head = head;
    }
    //其他代码先省略
    ....
}
```

* boolean isEmpty()实现分析<br>
需要判断链表是否为空的依据是头结点head是否为null, 当head==null时链表即为空链表:
```
public boolean isEmpty(){
    return this.head==null;
}
```

* int length()实现分析<br>
由于单链表的结点数就是其长度，因此我们需要遍历整个链表并获取结点的数量即可知道链表的程度。遍历链表需要从头结点head开始，为了不改变头结点的存储单元，声明变量p指向当前头结点和局部变量length, 然后p从头结点开始访问，沿着next地址链到达后继结点，逐个访问，直到最后一个结点，每经过一个结点length就加一，最后length的大小就是链表的大小。实现代码如下:
```
public int length(){
    int length=0; //标记长度的变量
    Node<T> p=head; //变量p指向头结点
    while(p!=null){
        length++;
        p=p.next;//后继结点赋值给p,继续访问
    }
    return length;
}
```

* T get(int index)实现分析<br>
在单链表中获取某个元素的值是一种比较费时间的操作，需要从头结点开始遍历直至传入值index指向的位置，其中需要注意的是index是从0开始计算，也就是说传递的index=3时，查找的是链表中的第4个位置的值。代码实现如下：
```
public T get(int index){
    if(this.head!=null && index>=0){
        int count=0;
        Node<T> p = this.head;
        //找到对应索引的点
        while(p!=null&&count<index){
            p=p.next;
            count++;
        }
        
        if(p!=null)
            return p.data;
    }
    return null;
}
```

* T set(int index, T data)实现分析<br>
根据传递的index查找某个值并替换其值为data, 实现原理跟get是基本一样的，先找到对应值所在的位置然后替换即可。代码如下：
```
public T set(int index, T data){
    if(this.head!=null && index>=0 && data!=null){
        Node<T> p=this.head;
        int count=0;
        //查找需要替换的结点
        while(p!=null&&count<index){
            p=p.next;
            count++;
        }
        
        //不为空直接替换
        if(p!=null){
            T oldData = p.data;
            p.data = data; //设置新值
            return oldData;
        }
    }
    return null;
}
```

* add(int index, T data)实现分析<br>
单链表的插入操作分四种情况：
    * a. 空表插入一个新节点，插入语句如下:
    ```
    head = new Node<T>(x,null);
    ```
    * b. 在链表的表头插入一个新结点(即链表的开始处)，此时表头head!=null, 因此head后继指针next应该指向新插入结点p, 而p的后继指针应该指向head原来的结点，代码如下:
    ```
    //创建新节点
    Node<T> p = new Node<T>(x,null);
    //p的后继指针指向head原来的结点
    p.next = head;
    //更新head
    head = p;
    ```
    以上代码可以合并为如下：
    ```
    //创建新结点，其后继为head原来的结点，head的新指向为新结点
    head = new Node<T>(x,head);
    ```
    * c. 在链表的中间插入一个新结点p,需要先找到给定插入位置的前一个结点，假设该结点为front, 然后改变front的后继指向为新结点p, 同时更新新结点p的后继指向为fornt原来的后继结点，即front.next, 代码实现如下：
    ```
    //新结点
    Node<T> p = new Node<T>(x,null);
    //更新p的后继指向
    p.next = front.next;
    //更新front的后继指向
    front.next = p;
    ```
    以上三句代码合并为如下:
    ```
    front.next = new Node<T>(x, front.next)
    ```
    * d. 在链表的表尾插入一个新结点, 在尾部插入时，同样需要查到要插入结点P的前一个位置的结点front, 该结点front为尾部结点，更改尾部结点的next指针指向新结点，新结点p的后继指针设置为null，代码实现如下：
    ```
    //front的next指针指向新结点，新结点的next指针设置为null
    front.next = new Node<T>(x,null);
    ```
    
到此我们也就可以发现单向链表中的中间插入和尾部插入其实可以合并为一种情况。整体实现如下：
```
public boolean add(int index, T data){
    if(data==null){
        return false;
    }
    
    //在头部插入
    if(this.head==null||index<=1){
        this.head = new Node<T>(data, this.head);
    }else{
        //在尾部或中间插入
        int count=0;
        Node<T> front = this.head;
        //找到要插入结点的位置的前一个结点
        while(front.next!=null&&count<index-1){
            front=front.next;
            count++;
        }
        //尾部添加和中间插入属于同种情况，毕竟当front为尾部结点时front.next==null
        front.next = new Node<T>(data,front.next);
    }
    return true;
}
```

* T remove(int index)删除结点实现分析
在单向链表中，根据传递index位置删除结点的操作分3种情况，并且删除后返回被删除结点的数据:
    * a. 删除链表头部(第一个)结点，此时需要删除头部head指向的结点，并更新head的结点指向:
    ```
    //头部删除，更新head指向
    head = head.next;
    ```
    * b. 删除链表的中间结点，与添加是同样的道理，需要先找到要删除结点r位置的前一个结点front，然后把front.next指向r.next,代码如下:
    ```
    Node<T> r = front.next;
    //更新结点指针指向
    front.next = r.next;
    r=null;
    ```
    * c. 删除链表的最后一个结点，通过遍历操作找到最后一个结点r的前一个结点front, 并把front.next设置为null, 代码如下：
    ```
    front.next = null;
    r=null;
    ```
    我们把中间删除和尾部删除合并为如下代码:
    ```
    Node<T> r = front.next;
    //如果不是尾部结点，更新结点front指针指向
    if(r!=null){
        front.next = r.next;
        r=null;
    }
    ```
    该方法整体代码实现如下:
    ```
    public T remove(int index){
        T old=null;
        
        if(this.head!=null&&index>=0){
            //直接删除的是头结点
            if(index==0){
                old = this.head.data;
                this.head = this.head.next;
            }else{
                Node<T> front = this.head;
                int count=0;
                //查找需要删除结点的前一个结点
                while(front.next!=null && count < index-1){
                    front = front.next;
                    count++;
                }
                
                //获取到要删除的结点
                Node<T> r = front.next;
                
                if(r!=null){
                    //获取旧值
                    old = r.data;
                    //更改指针指向
                    front.next = r.next;
                    //释放
                    r=null;
                }
            }
        }
        
        return old;
    }
    ```
