---
layout:     post
title:      Java数据结构与算法(二)
subtitle:   顺序表与链表
date:       2018-08-02
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 3. 线性表的链式存储设计与实现（链表）
## 3.1 链表的链式存储设计原理
通过前面对线性顺序表的分析，我们知道当创建顺序表时必须分配一块连续的内存存储空间，而当顺序表内部数组的容量不足时，则必须创建一个新的数组，然后把原数组的元素复制到新的数组中，这将浪费大量的时间。而在插入或删除元素时，可能需要移动数组中的元素，这也将消耗一定的时间。鉴于这种种原因，于是链表就出场了，链表在初始化时仅需要分配一个元素的存储空间，并且插入和删除新的元素也相当便捷，同时链表在内存分配上可以是不连续的内存，也不需要做任何内存复制和重新分配的操作，由此看来顺序表的缺点在链表中都变成了优势，实际上也是如此，当然链表也有缺点，主要是在访问单个元素的时间开销上。<br>
线性链表的存储结构是用若干个地址分散的存储单元存放数据元素的，逻辑上相邻的数据元素在物理位置上不一定相邻，因此每个存储单元中都会有一个地址指向域，这个地址指向域指明其后续元素的位置。在链表中存储的单元称为结点(Node), 一个结点至少包含了数据域和地址域，其中数据域用于存储数据，而地址域用于存储前驱或后继元素的地址。前面我们说过链表的插入和删除都相当便捷，这是由于链表的结点存储空间是在插入或者删除过程中动态申请和释放的，不需要预先给单链表分配存储空间的，从来避免了顺序表因存储空间不足需要扩充空间和复制元素的过程，提高了运行效率和存储空间的利用率

## 3.2 单链表的存储结构实现分析
最基本的存储单元Node代码如下：
```
/**
 * 单向链表结点
 */
public class Node<T> {
    public T data; //数据域
    public Node<T> next; //地址域
    
    public Node(T data){
        this.data = data;
    }
    
    public Node(T data, Node<T> next){
        this.data = data;
        this.next = next;
    }
}
```

创建一个单链表SingleLinkedList，声明一个单链表的头结点head, 代表链表的开始位置，如下:
```
public class SingleLinkedList<T> {
    protected Node<T> head; //带数据头结点
    
    public SingleLinkedList(Node<T> head){
        this.head = head;
    }
    //其他代码先省略
    ....
}
```

* boolean isEmpty()实现分析<br>
需要判断链表是否为空的依据是头结点head是否为null, 当head==null时链表即为空链表:
```
public boolean isEmpty(){
    return this.head==null;
}
```

* int length()实现分析<br>
由于单链表的结点数就是其长度，因此我们需要遍历整个链表并获取结点的数量即可知道链表的程度。遍历链表需要从头结点head开始，为了不改变头结点的存储单元，声明变量p指向当前头结点和局部变量length, 然后p从头结点开始访问，沿着next地址链到达后继结点，逐个访问，直到最后一个结点，每经过一个结点length就加一，最后length的大小就是链表的大小。实现代码如下:
```
public int length(){
    int length=0; //标记长度的变量
    Node<T> p=head; //变量p指向头结点
    while(p!=null){
        length++;
        p=p.next;//后继结点赋值给p,继续访问
    }
    return length;
}
```

