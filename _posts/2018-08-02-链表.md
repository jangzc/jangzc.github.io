---
layout:     post
title:      Java数据结构与算法(二)
subtitle:   顺序表与链表
date:       2018-08-02
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 3. 线性表的链式存储设计与实现（链表）
## 3.1 链表的链式存储设计原理
通过前面对线性顺序表的分析，我们知道当创建顺序表时必须分配一块连续的内存存储空间，而当顺序表内部数组的容量不足时，则必须创建一个新的数组，然后把原数组的元素复制到新的数组中，这将浪费大量的时间。而在插入或删除元素时，可能需要移动数组中的元素，这也将消耗一定的时间。鉴于这种种原因，于是链表就出场了，链表在初始化时仅需要分配一个元素的存储空间，并且插入和删除新的元素也相当便捷，同时链表在内存分配上可以是不连续的内存，也不需要做任何内存复制和重新分配的操作，由此看来顺序表的缺点在链表中都变成了优势，实际上也是如此，当然链表也有缺点，主要是在访问单个元素的时间开销上。<br>
线性链表的存储结构是用若干个地址分散的存储单元存放数据元素的，逻辑上相邻的数据元素在物理位置上不一定相邻，因此每个存储单元中都会有一个地址指向域，这个地址指向域指明其后续元素的位置。在链表中存储的单元称为结点(Node), 一个结点至少包含了数据域和地址域，其中数据域用于存储数据，而地址域用于存储前驱或后继元素的地址。前面我们说过链表的插入和删除都相当便捷，这是由于链表的结点存储空间是在插入或者删除过程中动态申请和释放的，不需要预先给单链表分配存储空间的，从来避免了顺序表因存储空间不足需要扩充空间和复制元素的过程，提高了运行效率和存储空间的利用率

## 3.2 单链表的存储结构实现分析
### 3.2.1 最基本的存储单元Node代码如下
```
/**
 * 单向链表结点
 */
public class Node<T> {
    public T data; //数据域
    public Node<T> next; //地址域
    
    public Node(T data){
        this.data = data;
    }
    
    public Node(T data, Node<T> next){
        this.data = data;
        this.next = next;
    }
}
```

创建一个单链表SingleLinkedList，声明一个单链表的头结点head, 代表链表的开始位置，如下:
```
public class SingleLinkedList<T> {
    protected Node<T> head; //带数据头结点
    
    public SingleLinkedList(Node<T> head){
        this.head = head;
    }
    //其他代码先省略
    ....
}
```

### 3.2.2 boolean isEmpty()实现分析<br>
需要判断链表是否为空的依据是头结点head是否为null, 当head==null时链表即为空链表:
```
public boolean isEmpty(){
    return this.head==null;
}
```

### 3.2.3 int length()实现分析<br>
由于单链表的结点数就是其长度，因此我们需要遍历整个链表并获取结点的数量即可知道链表的程度。遍历链表需要从头结点head开始，为了不改变头结点的存储单元，声明变量p指向当前头结点和局部变量length, 然后p从头结点开始访问，沿着next地址链到达后继结点，逐个访问，直到最后一个结点，每经过一个结点length就加一，最后length的大小就是链表的大小。实现代码如下:
```
public int length(){
    int length=0; //标记长度的变量
    Node<T> p=head; //变量p指向头结点
    while(p!=null){
        length++;
        p=p.next;//后继结点赋值给p,继续访问
    }
    return length;
}
```

### 3.2.4 T get(int index)实现分析<br>
在单链表中获取某个元素的值是一种比较费时间的操作，需要从头结点开始遍历直至传入值index指向的位置，其中需要注意的是index是从0开始计算，也就是说传递的index=3时，查找的是链表中的第4个位置的值。代码实现如下：
```
public T get(int index){
    if(this.head!=null && index>=0){
        int count=0;
        Node<T> p = this.head;
        //找到对应索引的点
        while(p!=null&&count<index){
            p=p.next;
            count++;
        }
        
        if(p!=null)
            return p.data;
    }
    return null;
}
```

### 3.2.5 T set(int index, T data)实现分析<br>
根据传递的index查找某个值并替换其值为data, 实现原理跟get是基本一样的，先找到对应值所在的位置然后替换即可。代码如下：
```
public T set(int index, T data){
    if(this.head!=null && index>=0 && data!=null){
        Node<T> p=this.head;
        int count=0;
        //查找需要替换的结点
        while(p!=null&&count<index){
            p=p.next;
            count++;
        }
        
        //不为空直接替换
        if(p!=null){
            T oldData = p.data;
            p.data = data; //设置新值
            return oldData;
        }
    }
    return null;
}
```

### 3.2.6 add(int index, T data)实现分析<br>
单链表的插入操作分四种情况：
* a. 空表插入一个新节点，插入语句如下:
```
head = new Node<T>(x,null);
```
* b. 在链表的表头插入一个新结点(即链表的开始处)，此时表头head!=null, 因此head后继指针next应该指向新插入结点p, 而p的后继指针应该指向head原来的结点，代码如下:
```
//创建新节点
Node<T> p = new Node<T>(x,null);
//p的后继指针指向head原来的结点
p.next = head;
//更新head
head = p;
```
以上代码可以合并为如下：
```
//创建新结点，其后继为head原来的结点，head的新指向为新结点
head = new Node<T>(x,head);
```
* c. 在链表的中间插入一个新结点p,需要先找到给定插入位置的前一个结点，假设该结点为front, 然后改变front的后继指向为新结点p, 同时更新新结点p的后继指向为fornt原来的后继结点，即front.next, 代码实现如下：
```
//新结点
Node<T> p = new Node<T>(x,null);
//更新p的后继指向
p.next = front.next;
//更新front的后继指向
front.next = p;
```
以上三句代码合并为如下:
```
front.next = new Node<T>(x, front.next)
```
* d. 在链表的表尾插入一个新结点, 在尾部插入时，同样需要查到要插入结点P的前一个位置的结点front, 该结点front为尾部结点，更改尾部结点的next指针指向新结点，新结点p的后继指针设置为null，代码实现如下：
```
//front的next指针指向新结点，新结点的next指针设置为null
front.next = new Node<T>(x,null);
```
    
到此我们也就可以发现单向链表中的中间插入和尾部插入其实可以合并为一种情况。整体实现如下：
```
public boolean add(int index, T data){
    if(data==null){
        return false;
    }
    
    //在头部插入
    if(this.head==null||index<=1){
        this.head = new Node<T>(data, this.head);
    }else{
        //在尾部或中间插入
        int count=0;
        Node<T> front = this.head;
        //找到要插入结点的位置的前一个结点
        while(front.next!=null&&count<index-1){
            front=front.next;
            count++;
        }
        //尾部添加和中间插入属于同种情况，毕竟当front为尾部结点时front.next==null
        front.next = new Node<T>(data,front.next);
    }
    return true;
}
```

### 3.2.7 T remove(int index)删除结点实现分析<br>
在单向链表中，根据传递index位置删除结点的操作分3种情况，并且删除后返回被删除结点的数据:
* a. 删除链表头部(第一个)结点，此时需要删除头部head指向的结点，并更新head的结点指向:
```
//头部删除，更新head指向
head = head.next;
```
* b. 删除链表的中间结点，与添加是同样的道理，需要先找到要删除结点r位置的前一个结点front，然后把front.next指向r.next,代码如下:
```
Node<T> r = front.next;
//更新结点指针指向
front.next = r.next;
r=null;
```
* c. 删除链表的最后一个结点，通过遍历操作找到最后一个结点r的前一个结点front, 并把front.next设置为null, 代码如下：
```
front.next = null;
r=null;
```
我们把中间删除和尾部删除合并为如下代码:
```
Node<T> r = front.next;
//如果不是尾部结点，更新结点front指针指向
if(r!=null){
    front.next = r.next;
    r=null;
}
```
该方法整体代码实现如下:
```
public T remove(int index){
    T old=null;
    if(this.head!=null&&index>=0){
        //直接删除的是头结点
        if(index==0){
            old = this.head.data;
            this.head = this.head.next;
        }else{
            Node<T> front = this.head;
            int count=0;
            //查找需要删除结点的前一个结点
            while(front.next!=null && count < index-1){
                front = front.next;
                count++;
            }
                
            //获取到要删除的结点
            Node<T> r = front.next;
                
            if(r!=null){
                //获取旧值
                old = r.data;
                //更改指针指向
                front.next = r.next;
                //释放
                r=null;
            }
        }
    }
        
    return old;
}
```
### 3.2.8 void clear()实现分析<br>
清空链表是一件非常简单的事情，只需让head=null即可,代码如下：
```
public void clear(){
    this.head = null;
}
```

## 3.3 带头结点的单链表以及循环单链表的实现
### 3.3.1 带头结点的单链表
前面分析的单链表是不带特殊头结点的，所谓的特殊头结点就是一个没有值的结点即:
```
//没有带值的头结点
Node<T> head = new Node<T>(null,null);
```
那么多了头结点的单向链表有什么好处呢？通过对没有带头结点的单链表的分析，我们可以知道，在链表插入和删除时都需要区分操作位，比如插入操作就分头部插入和中间或尾部插入两种情况，如果现在有不带数据的头结点，那么对于单链表的插入和删除不再区分操作的位置，也就是说头部、中间、尾部插入都可以视为一种情况处理了，这是因为此时头部插入和头部删除无需改变head的指向了。
同时为了使链表在尾部插入时达到更加高效，我们可在链表内增加一个尾部指向的结点rear, 如果我们是在尾部添加结点，那么此时只要通过尾部结点rear进行直接操作即可，无需从表头遍历到表尾。从尾部直接插入的代码实现如下：
```
public boolean add(T data){
    if(data==null)
        throw new NullPointerException();
    
    this.rear.next = new Node<T>(data);
    //更新尾部指针的指向
    this.rear = this.rear.next
    return true;
}
```
只要获取当前的尾部指向的结点rear并把新结点赋值给rear.next,最后更新rear结点的值即可，完全不用遍历操作，但是如果是根据index来插入的话，遍历部分结点还是少不了的，下面看看根据index插入的代码实现，由于有了头结点，头部、中间、尾部插入无需区分操作位，都视为一种情况处理。
```
public boolean add(int index, T data){
    //无需区分位置操作，中间/头部/尾部插入
    int j=0;
    Node<T> p=this.head;
    //查找到插入位置即index的前一个结点
    while(p.next!=null&&j<index){
        p=p.next;
        j++;
    }
    //将新插入的结点的后继指针指向p.next
    Node<T> q = new Node<T>(data,p.next);
    //更改指针指向
    p.next = q;
    
    //如果是尾部指针
    if(p==this.rear)
        this.rear = q;
    
    return true;
}
```
最后在看看删除的代码实现，由于删除和插入的逻辑和之前不带头结点的单链表分析过的原理是一样的，主要注意遍历的其实结点变化就行。
```
public T remove(int index){
    T old=null;
    
    //无需区分头删除或中间删除或尾部删除的情况
    if(index>=0){
        Node<T> p = this.head;
        int j=0;
        //查找需要删除位置的前一个结点
        while(p.next!=null && j<index){
            p=p.next;
            j++;
        }
        
        //获取要删除的结点
        Node<T> r = p.next;
        
        if(r!=null){
            //获取旧值
            old = r.data;
            //如果恰好是尾部结点，则更新rear指向
            if(r==this.rear){
                this.rear = p;
            }
            //更改指针指向
            p.next=r.next;
        }
    }
    return old;
}
```

### 3.3.2 循环单链表
有上述的分析基础，循环带链表(Circular Single Linked List)相对来说就比较简单了，所谓的循环单链表是指链表中的最后一个结点的next域指向了头结点head, 形成环形的结构。

此时的循环单链表有如下的特点
* a. 当循环链表为空链表时，head指向头结点，head.next=head.
* b. 尾部指向rear代表最后一个结点，则有rear.next=head.
在处理循环单链表时，我们只需要注意在遍历循环链表时，避免进入死循环即可，也就是在判断循环链表是否达到结尾时，由之前的如下判断:
```
Node<T> p=this.head;
while(p!=null){
    p=p.next;
}
```
在循环链表中改为如下判断：
```
Node<T> p=this.head;
while(p!=this.head){
    p=p.next;
}
```
因此除了判断条件不同，其他操作算法与单链表基本是一样的。

## 3.4 单链表的效率分析<br>
由于单链表并不是随机存取结构，即使单链表在访问第一个结点时花费的时间为常数时间，但是如果需要访问第i个结点，需要从头结点head开始遍历部分链表，进行i次的p=p.next操作，这种情况类似于前面计算顺序表需要平均移动元素的总数，因此链表也需要平均进行n/2次的p=p.next操作，也就是说get(i)和set(i,x)的时间复杂度都为O(n)<br>
由于链表在插入和删除结点方面十分高效的，因此链表比较适合那些插入删除频繁的场景使用，单纯从插入操作来看，我们假设front指向的是单链表中的一个结点，此时插入front的后继结点所消耗的时间为常数时间O(1), 但如果此时需要在front的前面插入一个结点或者删除结点自己时，由于front并没有前驱指针，单凭front根本无法知道前驱结点，所以必须从链表的表头遍历至front的前一个结点再执行插入或者删除操作，而这个查询操作所消耗的时间为O(n),因此在已经front结点需要插入前驱结点或者删除自己时，消耗的时间为O(n)。当然这种情况并不是无法解决的，后面的双链表就可以很好解决这个问题，双链表是每个结点都同时拥有前驱后继结点的链表，这样的话上面的问题就迎刃而解了。

