---
layout:     post
title:      Java数据结构与算法(二)
subtitle:   顺序表与链表
date:       2018-08-02
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 3. 线性表的链式存储设计与实现（链表）
## 3.1 链表的链式存储设计原理
通过前面对线性顺序表的分析，我们知道当创建顺序表时必须分配一块连续的内存存储空间，而当顺序表内部数组的容量不足时，则必须创建一个新的数组，然后把原数组的元素复制到新的数组中，这将浪费大量的时间。而在插入或删除元素时，可能需要移动数组中的元素，这也将消耗一定的时间。鉴于这种种原因，于是链表就出场了，链表在初始化时仅需要分配一个元素的存储空间，并且插入和删除新的元素也相当便捷，同时链表在内存分配上可以是不连续的内存，也不需要做任何内存复制和重新分配的操作，由此看来顺序表的缺点在链表中都变成了优势，实际上也是如此，当然链表也有缺点，主要是在访问单个元素的时间开销上。<br>
线性链表的存储结构是用若干个地址分散的存储单元存放数据元素的，逻辑上相邻的数据元素在物理位置上不一定相邻，因此每个存储单元中都会有一个地址指向域，这个地址指向域指明其后续元素的位置。在链表中存储的单元称为结点(Node), 一个结点至少包含了数据域和地址域，其中数据域用于存储数据，而地址域用于存储前驱或后继元素的地址。前面我们说过链表的插入和删除都相当便捷，这是由于链表的结点存储空间是在插入或者删除过程中动态申请和释放的，不需要预先给单链表分配存储空间的，从来避免了顺序表因存储空间不足需要扩充空间和复制元素的过程，提高了运行效率和存储空间的利用率

## 3.2 单链表的存储结构实现分析
最基本的存储单元Node代码如下：
```
/**
 * 单向链表结点
 */
public class Node<T> {
    public T data; //数据域
    public Node<T> next; //地址域
    
    public Node(T data){
        this.data = data;
    }
    
    public Node(T data, Node<T> next){
        this.data = data;
        this.next = next;
    }
}
```
