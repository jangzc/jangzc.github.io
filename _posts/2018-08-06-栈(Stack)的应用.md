---
layout:     post
title:      Java数据结构与算法(五)
subtitle:   栈(Stack)的应用
date:       2018-08-06
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

## 5.4 栈的应用<br>
栈是一种很重要的数据结构，在计算机中有着很广泛的应用，如下一些操作都应用到了栈:
  * 符号匹配
  * 中缀表达式转换为后缀表达式
  * 计算后缀表达式
  * 实现函数的嵌套调用
  * HTML和XML文件中的标签匹配
  * 网页浏览器中已经访问页面的历史记录

### 5.4.1 符号匹配分析<br>
在编写程序的过程中，我们经常会遇到诸如圆括号"()"与花括号"{}",这些符号都必须是左右匹配的，这就是我们所说的符号匹配类型，当然符合不仅需要个数相等，而且需要左先后右的依次出现，否则就不符合匹配规则，如")("，明显是错误的匹配，而"()"才是正确的匹配。有时候符号如括号还会嵌套出现，如"9-(5+(5+1))"，而嵌套的匹配原则是一个右括号与其前面最近的一个括号匹配，事实上编译器帮我们检查语法错误也是执行一样的匹配原理，而这一系列操作都需要借助栈来完成，接下来我们使用栈来实现括号"()"是否匹配的检测。
判断原则如下:str="((5-3) * 8 - 2 )":
  * a. 设置str是一个表达式字符串，从左到右依次对字符串str中的每个字符char进行语法检测，如果char是左括号则入栈，如果char是右括号则出栈(有一对匹配就可以去匹配一个左括号，因此可以出栈)，如此时出栈的字符char为左括号，则说明这一对括号匹配正常，如果此时栈为空或者出栈字符不为左括号，则表示缺少与char匹配的左括号，即目标不完整
  * b. 重复执行a操作，直到str检测结束，如果此时栈为空，则全部括号匹配，如果栈中还有左括号，说明缺少右括号.

用栈作为存储容器实现如下：
```
public class CheckExpression {
  public staic String isValid(String expstr) {
    //创建栈
    LinkedStack<String> stack = new LinkedStack<>();
    
    int i=0;
    while(i<expstr.length()){
      char ch = expstr.chartAt(i);
      i++;
      switch(ch)
      {
        case '(': 
          stack.push(ch+"");//左括号直接入栈
          break;
        case ')':
          if(stack.isEmpty()||!stack.pop().equals("("))//遇到右括号，左括号直接出栈
            return "(";
      }
    }
    
    //最后检查是否为空，为空则通过检测
    if(stack.isEmpty()){
      return "Pass";
    }else{
      return "Fail"
    }
  }
  
  public static void main(String args[]){
    String expstr = "((5-3)*8-2)";
    System.out.println(expstr+" "+isValid(expstr));
  }
}
```

### 5.4.2 中缀表达式转换为后缀表达式<br>
我们先来了解一下什么是中缀表达式，评测所见到的计算表达式都算是中缀表达式:
```
//1+3*(9-2)+9 ---->中缀表达式
```
了解中缀表达式后来看看其定义：将运算符写在两个操作数中间的表达式成为中缀表达式。在中缀表达式中，运算符拥有不同的优先级，同时也可以使用圆括号改变运算次序，由于这两点的存在，使中缀表达式的运算规则比较复杂，求值的过程不能从左往右依次计算，当然这也是相对计算机而言罢了。既然计算机感觉复杂，那么我们就需要把中缀表达式转化成计算机容易计算而且不复杂的表达式，这就是后缀表达式了，在后缀表达式中，运算符是没有优先级的，整个计算都是遵守从左往右的次序依次计算的：
```
//1+3*(9-2)+9       转化前的中缀表达式
//1 3 9 2 - * + 9 + 转化后的后缀表达式
```
中缀转后缀的转换过程需要用到栈，这里我们假设栈A用于协助转换，并使用数组B用于存放转化后的后缀表达式，具体过程如下:
* 1). 如果需要操作数，我们就直接将其放如数组B中。
* 2). 如果遇到运算符，则我们将其放入到栈A中，遇到左括号时我们也将其放入栈A中。
* 3). 如果遇到一个右括号，则将栈元素弹出，将弹出的运算符输入并存入数组B中，直到遇到左括号为止。注意，左括号只弹出不存入数组。
* 4). 如果遇到任何其他的操作符，如"+"," * ","("等，从栈中弹出元素存入数组B直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入栈中。有一点需要注意，只有在遇到")"的情况下我们才弹出"(",其他情况我们都不会弹出"("。
* 5). 如果我们读到了输入的末尾，则将栈中所有元素依次弹出存入到数组B中。
* 6). 到此，中缀表达式转化为后缀表达式完成，数组存储的元素顺序就代表转化后的后缀表达式。

简单分析一下流程:
当遇到操作数时，直接存入数组B中<br>
当i=1时，此时运算符为+,直接入栈，<br>
当i=3再遇到运算符*,由于栈内的运算符+优先级比* 低，因此直接入栈<br>
当i=4时，遇到运算符"("，直接入栈<br>
当i=6时，遇到运算符"-",直接入栈<br>
当i=8时，遇到")", "-"和"("直接出栈，其中运算符"-"存入后缀数组B中<br>
当i=9时，遇到"+",由于* 优先级比+高，而+与+平级，因此* 和+出栈，存入数组B，而后面的+再入栈<br>
当i=10时，结束，+直接出栈存入数组B<br>

接着转成后缀后，我们来看看计算机如何利用后缀表达式进行结果运算，通过前面的分析可知，后缀表达式是没有括号的，而且计算过程是按照从左到右依次进行的，因此在后缀表达的求值过程中，当遇到运算符时，只需要取两个操作数直接进行计算即可，而当遇到操作数时，不能立即进行求值计算，此时必须先把操作数保存等待获取到运算符时再进行计算，如果存在多个操作数，其运算次序是后出现的操作数先进行运算，也就是后进先运算，因此后缀表达式的计算过程我们也需要借助栈来完成，该栈用于存放操作数。
过程如下:
* 1). 如果ch是数字，先将其转换为证书再入栈
* 2). 如果是运算符，将两个操作数出栈，计算结果再入栈
* 3). 重复1)和2)直到后缀表达式结束，最终栈内的元素即为计算的结果。

实现如下:
```
/**
*中缀转后缀，然偶计算后缀表达式的值
*/
public class CalculateExpression {
    //中缀转后缀
    public static String toPostfix(String expstr){
        //创建栈，用于存储运算符
        SeqStack<String> stack = new SeqStack<>(expstr.length());
        
        String postfix="";//存储后缀表达式的字符串
        int i=0;
        while (i<expstr.length()){
            char ch=expstr.charAt(i);
            switch(ch):
            {
                case '+':
                case '-':
                    //栈内元素处理：当栈不为空或者栈顶元素不是左括号时，直接出栈，因为此时只有可能是+-*/
                    while(!stack.isEmpty() && !stack.peek().equals("(")){
                        postfix += stack.pop();
                    }
                    //入栈
                    stack.push(ch+"");
                    i++;
                    break;
                case '*':
                case '/'：
                    //遇到*/这俩运算符时
                    while (!stack.isEmpty() && (stack.peek().equals("*")||stack.peek().equals("/"))){
                        postfix += stack.pop();
                    }
                    stack.push(ch+"");
                    i++;
                    break;
                case '(':
                    //左括号直接入栈
                    stack.push(ch+"");
                    i++;
                    break;
                case ')':
                    //遇到右括号
                    String out = stack.pop();
                    while (out!=null && !out.equals("(")){
                        postfix += out;
                        out = stack.pop();
                    }
                    i++;
                    break;
                default:
                    //操作数直接入栈
                    while(ch>='0' && ch<='9'){
                        postfix += ch;
                        i++;
                        if(i<expstr.length())
                            ch=expstr.charAt(i);
                        else
                            ch='=';
                    }
                    //分隔符
                    postfix += "";
                    break;
            }
        }
        //最后把所有运算符出栈
        while (!stack.isEmpty())
            postfix += stack.pop();
        return postfix;
    }
    
    //计算后缀表达式的值
    public static int calculatePostfixValue(String postfix){
        //栈用于存储操作数，协助运算
        LinkedStack<Integer> stack = new LinkedStack<>();
        
        int i=0, result=0;
        
        while(i<postfix.length()){
            char ch=postfix.charAt(i);
            if(ch>='0' && ch<='9'){
                result=0;
                while(ch!=' '){
                    //将整数字符串转为整数值ch=90
                    result = result * 10 + Integar.parseInt(ch+"");
                    i++;
                    ch = postfix.charAt(i);
                }
                i++;
                stack.push(result);//操作数入栈
            }else{
                //ch是运算符，出栈栈顶的前两个元素
                int y = stack.pop();
                int x = stack.pop();
                switch (ch){
                    case '+': result = y + x; break;
                    case '-': result = x -y; break;
                    case '*': result = x*y; break;
                    case '/': result = x/y; break;
                }
                //将运算结果入账
                stack.push(result);
                i++;
            }
        }
        //将最后的结果出栈并返回
        return stack.pop();
    }
}
```
