---
layout:     post
title:      Java数据结构与算法(四)
subtitle:   栈(Stack)
date:       2018-08-05
author:     Jang
header-img: img/post-bg-debug.png
catalog: true
tags:
    - Algorithm
---

# 5. 栈的抽象数据类型<br>
栈是一种用于存储数据的简单数据结构，有点类似链表或者顺序表(统称线性表)，栈与线性表的最大区别是数据的存取操作，我们可以这样认为栈(Stack)是一种特殊的线性表，其插入和删除操作只允许在线性表的一端进行，一般而言，把允许操作的一端成为栈顶(Top), 不可操作的一端成为栈底(Bottom),同时把插入元素的操作成为入栈(Push),删除元素的操作称为出战（Pop)。若栈中没有任何元素，则称为空栈。<br>

栈只能从栈顶存取元素，同时先进入的元素反而是后出，而栈顶永远指向站内最顶部的元素。到此可以给出栈的正式定义：栈(Stack)是一种有序特殊的线性表，只能在表的一端（称为栈顶，top，总是指向栈顶元素）执行插入和删除操作，最后插入的元素将第一个被删除，因为栈也称为后进先出或者先进后出的线性表。栈的基本操作创建栈，叛空，入栈，出栈，获取栈顶元素等，注意栈不支持对指定位置进行删除，插入.

## 5.1 顺序栈的设计与实现<br>
顺序栈，顾名思义就是采用顺序表实现的栈，顺序栈的内部以顺序表为基础，实现对元素的存取操作，当然我们还可以采用内部数据实现顺序栈，在这里我们使用内部数据组来实现栈。

### 5.1.1 获取栈顶元素值peek<br>
```
public T　peek(){
    if(isEmpty()){
        throw new EmptyStackException();
    }
    return array[top];
}
```

### 5.1.2 从栈添加元素(更新栈顶top指向)
```
/**
*添加和元素，从栈顶(数据尾部)插入，容量不足时，需要扩容
*/
public void push(T data){
    //判断容量是否充足
    if(array.length==size){
        ensureCapacity(size * 2 + 1)
    }    
    //从栈顶添加元素
    array[++top]=data;
}
```

### 5.1.3 栈弹出栈顶元素(删除并获取值)
```
/**
*从栈顶(数序表尾部)删除
*/
public T pop(){
    if(isEmpty()){
        throw new EmptyStackException();
    }
    size--;
    return array[top--];
}
```

### 5.1.4 完整的顺序栈代码<br>
```
public class SeqStack<T> {
    //栈顶指针，-1代表空栈
    private int top=-1;
    
    //容量大小默认为10
    private int capacity=10;
    
    //存放元素的数组
    private T[] array;
    
    private int size;
    
    public SeqStack(int capacity){
        array = (T[]) new Object[capacity];
    }
    
    public Seqstack(){
        array = (T[]) new Object[this.capacity];
    }
    
    public int size(){
        return size;
    }
    
    public boolean isEmpty(){
        return this.top==-1;
    }
    
    //添加元素，从栈顶(数组尾部)插入
    public void push(T data){
        //判断容量是否充足
        if(array.length==size)
            ensureCapacity(size*2+1)
            
        //从栈顶添加元素
        array[++top]=data;
        
        size++;
    }
    
    //获取栈顶元素的值，不删除
    public T peek(){
        if(isEmpty()){
            new EmptyStackEception();
        }
        return array[top];
    }
    
    //从栈顶(顺序表尾部)删除
    public T pop(){
        if(isEmpty()){
            new EmptyStackException();
        }
        size--;
        return array[top--];
    }
    
    //扩容的方法
    public void ensureCapacity(int capacity){
        //如果需要扩展的容量比现在的容量还小，则无需扩容
        if(capacity<size)
            return;
        
        T[] old = array;
        array = (T[]) new Object[capacity];
        //复制元素
        for (int i=0; i<size; i++){
            array[i]=old[i];
        }
    }
    
    public static void main(String[] args){
        SeqStack<String> s = new SeqStack<>();
        s.push("A");
        s.push("B");
        s.push("C");
        int l=s.size();//size在减少，必须先记录
        for(int i=0;i<l;i++)
            System.out.println("s.pop-->"+s.pop());
    }
}
```

## 5.2 链式栈的设计与实现<br>
所谓链式栈(Linked Stack), 就是采用链式存储结构的栈，由于我们操作的是栈顶一端，因为这里采用单链表(不带头结点)作为基础，直接实现栈的添加，获取，删除等主要操作即可。
```
public class LinkedStack<T> {
    private Node<T> top;
    
    private int size;
    
    public LinkedStack(){
        this.top = new Node<>();
    }
    
    public int size(){
        return size;
    }
    
    public boolean isEmpty(){
        return top==null || top.data==null;
    }
    
    public void push(T data){
        if(data==null){
            throw new StackException("data can not be null");
        }
        if(this.top==null){//调用pop()后,top可能为null
            this.top = new Node<>(data);
        }else if(this.top.data==null){
            this.top.data=data;
        }else {
            Node<T> p=new Node<>(data, this.top);
            top=p;//更新栈顶
        }
        size++;
    }
    
    public T peek(){
        if(isEmpty()){
            return null;
        }
        
        return top.data;
    }
    
    public T pop(){
        if(isEmpty()){
            return null;
        }
        
        T data = top.data;
        top = top.next;
        size--;
        return data;
    }
}
```

## 5.3 顺序栈与链式栈各个操作的时间复杂度

操作 | 顺序栈 | 链式栈
---- | --- | ---
SeqStack空间复杂度(用于N次push) | O(n) | O(n)
push() | O(1) | O(1)
pop() | O(1) | O(1)
peek() | O(1) | O(1)
isEmpty | O(1) | O(1)
由此可知栈的主要操作都可以在常数时间内完成，这主要是因为栈只对一端进行操作，而且操作的只是栈顶元素。
